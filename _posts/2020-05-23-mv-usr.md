---
layout: post
title:  "mv /usr"
date:   2020-05-23 00:00:00 +0000
categories: tutorial
---

The other day I was helping a colleague clear some space on a tiny root volume. Half of the reason for the maxed out root volume as a bloated /usr directory.
There was another disk, /local, with a lot more space. Plan was to move /usr there and make a symlink from /usr to /local/usr

What could go wrong...

```
[ec2-user@ip-172-31-2-57 /]$ sudo -i

[root@ip-172-31-2-57 ~]# cd /
[root@ip-172-31-2-57 /]# mv /usr /local/

[root@ip-172-31-2-57 /]# ln -s /local/usr usr
-bash: ln: command not found
```

Okay, not entirely unexpected; the ln binary has moved. Let's invoke it directly.

We can use the echo builtin (thank God for builtins!) to verify it's here now:

```
[root@ip-172-31-2-57 /]# echo /local/usr/bin/l*
/local/usr/bin/ln
```

And invoking it:

```
[root@ip-172-31-2-57 /]# /local/usr/bin/ln --help
-bash: /local/usr/bin/ln: /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory
```

What? Not good, let's undo this:

```
[root@ip-172-31-2-57 /]# /local/usr/bin/mv /local/usr /usr
-bash: /local/usr/bin/mv: /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory
```

So mv doesn't work anymore.

We can't undo this.

Shit.

## Rewind.

What did the system look like before? Through the magic of time travel (okay, I launch another identical VM to poke around on) we see that quite a few directories in root already symlink to /usr.

```
[ec2-user@ip-172-31-2-57 strace]$ ls -l / | grep usr
lrwxrwxrwx  1 root root    7 Apr  7 01:50 bin -> usr/bin
lrwxrwxrwx  1 root root    7 Apr  7 01:50 lib -> usr/lib
lrwxrwxrwx  1 root root    9 Apr  7 01:50 lib64 -> usr/lib64
lrwxrwxrwx  1 root root    8 Apr  7 01:50 sbin -> usr/sbin
drwxr-xr-x 13 root root  155 Apr  7 01:50 usr
```

So those are all broken. Even if it looked like a binary wasn't going to be impacted by this because it was in /bin or /sbin, that binary has moved. Similarly, and more importantly, even though we might expect the dynamic libraries in /lib and /lib64 to still be reachable, nope, they're gone too.

## Dynamic linking

Interesting that we're seeing "No such file or directory" when trying to invoke the executable. Does that mean I'm invoking the wrong path, and the executable isn't there?

No. 

What's actually going on is that the dynamic linker is unable to do its job.

When loading a dynamically linked executable (which almost everything is) the kernel *actually* executes the dynamic linker/loader, with your executable as an argument to it.
That error message is useful: the kernel is telling us that it can't find the dynamic linker/loader.

A note on terminology: often we refer to the `ld` executable that's run as the last step of compiling as the linker; that's the compile-time linker. Now we're talking about the runtime dynamic linker; the thing that actually load the shared object into memory and resolves the references from your dynamic executable to the symbols provided by the shared objects. So the term "linker" can refer to two different ends of the same ecosystem. In this case we're talking about the runtime end.

We know where the linker has gone. Invoking it manually (rather than expecting the kernel to do it for us) and supplying our dynamic executable as an argument.

```
[root@ip-172-31-2-57 /]# /local/usr/lib64/ld-linux-x86-64.so.2 
Usage: ld.so [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]
You have invoked `ld.so', the helper program for shared library executables.

[root@ip-172-31-2-57 /]# /local/usr/lib64/ld-linux-x86-64.so.2 /local/usr/bin/ln
/local/usr/bin/ln: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory
```

Progress, but still sadness. The linker ran, and inspected out dynamic executable, ls, but then couldn't find the shared object it needed.

Where should this object be? The magic of time travel tells us:

```
-rwxr-xr-x 1 root root 54360 Jan 23 19:07 /usr/bin/ln
[ec2-user@ip-172-31-2-57 strace]$ ldd /usr/bin/ln
	linux-vdso.so.1 (0x00007ffecb1aa000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f164c353000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f164c6fe000)
```

So libc expected it to be there. Let's tell the linker to look in the new place.

The man page tells us we can do this with `LD_LIBARY_PATH` http://man7.org/linux/man-pages/man8/ld.so.8.html

```
[root@ip-172-31-2-57 /]# echo /local/usr/lib64/libc.so.*
/local/usr/lib64/libc.so.6

[root@ip-172-31-2-57 /]# export LD_LIBRARY_PATH=/local/usr/lib64/
[root@ip-172-31-2-57 /]# /local/usr/lib64/ld-linux-x86-64.so.2 /local/usr/bin/ln
/local/usr/bin/ln: missing file operand
Try '/local/usr/bin/ln --help' for more information.
```

Whoop whoop!

```
[root@ip-172-31-2-57 /]# /local/usr/lib64/ld-linux-x86-64.so.2 /local/usr/bin/ln -s /local/usr/ usr
[root@ip-172-31-2-57 /]# echo $?
0
```

```
[root@ip-172-31-2-57 /]# ls -l / | grep usr
lrwxrwxrwx   1 root root    7 Apr  7 01:50 bin -> usr/bin
lrwxrwxrwx   1 root root    7 Apr  7 01:50 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Apr  7 01:50 lib64 -> usr/lib64
lrwxrwxrwx   1 root root    8 Apr  7 01:50 sbin -> usr/sbin
lrwxrwxrwx   1 root root   11 May 23 22:12 usr -> /local/usr/
```

It's usable again. :-)
